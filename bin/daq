#!/usr/bin/python
# -*- coding: utf-8 -*-
### BEGIN LICENSE
# Copyright (C) 2009 HenkPostma <henkpm@gmail.com>
# This program is free software: you can redistribute it and/or modify it 
# under the terms of the GNU General Public License version 3, as published 
# by the Free Software Foundation.
# 
# This program is distributed in the hope that it will be useful, but 
# WITHOUT ANY WARRANTY; without even the implied warranties of 
# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
# PURPOSE.  See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along 
# with this program.  If not, see <http://www.gnu.org/licenses/>.
### END LICENSE

import sys
import os
import gtk
import time 
import commands
import glob
import datetime
import fcntl 

import gobject 

from PythonMagick import Image
from numpy import *
from numpy import histogram
from numpy.fft import * 
from pylab import * 

global im_pos
im_pos = 0 
global im_buffer
global im_scroll
global directory 
directory = ""

# optional Launchpad integration
# this shouldn't crash if not found as it is simply used for bug reporting
try:
    import LaunchpadIntegration
    launchpad_available = True
except:
    launchpad_available = False

try:
    import comedi
except:
    print "Cannot load comedi module, please install python-libcomedi"

from matplotlib.figure import Figure
from numpy import arange, sin, pi
from time import localtime, strftime

outsubdevice = "" # 1
insubdevice = "" # 0

imgext = "svg"
imgext2 = "png"

gpibwrite = "/home/bin/gpib-write"

device = "/dev/comedi0"

def SetComediDevice():
    if os.path.isfile("/proc/comedi"):
        device = "/dev/comedi0"
        try:
            dev = comedi.comedi_open(device)
            global insubdevice
            insubdevice = comedi.comedi_get_read_subdevice(dev)
        #    print "subdevice for input = " + str(insubdevice)
            global outsubdevice
            outsubdevice = comedi.comedi_get_write_subdevice(dev)
        #    print "subdevice for output = " + str(outsubdevice)
            comedi.comedi_close(dev)
            return "/dev/comedi0"
        except:
            print "cannot open /dev/comedi0, permissions?"
    else:
        return ""

SetComediDevice()

print "DAQ device is " + device 
print "subdevice for input = " + str(insubdevice)
print "subdevice for output = " + str(outsubdevice)

import getpass
basedir = ""
user = getpass.getuser()
print "User is " + user
import socket

hostname = socket.gethostname()

# Check if we are working in the source tree or from the installed 
# package and mangle the python path accordingly
if os.path.dirname(sys.argv[0]) != ".":
    if sys.argv[0][0] == "/":
        fullPath = os.path.dirname(sys.argv[0])
    else:
        fullPath = os.getcwd() + "/" + os.path.dirname(sys.argv[0])
else:
    fullPath = os.getcwd()
sys.path.insert(0, os.path.dirname(fullPath))

from matplotlib.backends.backend_gtkcairo import FigureCanvasGTKCairo as FigureCanvas
#from matplotlib.backends.backend_gtkagg import FigureCanvasGTKAgg as FigureCanvas
#from matplotlib.backends.backend_gtkagg import NavigationToolbar2GTKAgg as NavigationToolbar

fig = Figure(figsize=(5,4), dpi=80)
canvas = FigureCanvas(fig)

tfig = Figure(figsize=(5,4), dpi=80)
tcanvas = FigureCanvas(tfig)

tt2fig = Figure(figsize=(5,4), dpi=80)
tt2canvas = FigureCanvas(tt2fig)

trfig = Figure(figsize=(5,4), dpi=80)
trcanvas = FigureCanvas(trfig)

rffig = Figure(figsize=(5,4), dpi=80)
rfcanvas = FigureCanvas(rffig)

rf2fig = Figure(figsize=(5,4), dpi=80)
rf2canvas = FigureCanvas(rf2fig)

alignfig = Figure(figsize=(5,4), dpi=80)
aligncanvas = FigureCanvas(alignfig)

from daq import AboutDaqDialog, PreferencesDaqDialog
from daq.daqconfig import getdatapath

def diowrite(subdevice, channel, data):
	dev = comedi.comedi_open("/dev/comedi0")
	ret1 = comedi.comedi_dio_config(dev, subdevice, channel, comedi.COMEDI_OUTPUT)

	if ret1 == 1:
		pass
	else:
		print "initialisation failed"
		
	ret=comedi.comedi_dio_write(dev, subdevice, channel, data)

	if ret == 1:
		pass
	else:
		print "setting failed"
	comedi.comedi_close(dev)
	
def writeline(delayperpoint,vx,vy,dvx,dvy,N):
    beamblank()
    for i in range(0, N+1):
        setx(vx+float(dvx)*(float(i)-float(N)/2)/(float(N)))
        print "x", (vx+float(dvx)*(float(i)-float(N)/2)/(float(N)))
        sety(vy+float(dvy)*(float(i)-float(N)/2)/(float(N)))
        print "y", (vy+float(dvy)*(float(i)-float(N)/2)/(float(N)))
        timedbeamunblank(delayperpoint)
    beamblank()

def timedbeamunblank(delay):
    dev = comedi.comedi_open("/dev/comedi0")

    subdevice = 2
    channel = 0
    data = 0
    ret1 = comedi.comedi_dio_config(dev, subdevice, channel, comedi.COMEDI_OUTPUT)

    if ret1 == 1:
        pass
    else:
        print "initialisation failed"

    start_time = datetime.datetime.now()   
    ret=comedi.comedi_dio_write(dev, subdevice, channel, data)
    blanked_time = datetime.datetime.now()
    
    if ret == 1:
        pass
    else:
        print "setting failed"

    time.sleep(delay)
        
    data = 1
    ret=comedi.comedi_dio_write(dev, subdevice, channel, data)
    end_time = datetime.datetime.now()

    print "blanked_time =", blanked_time  - start_time
    print "end_time =", end_time  - start_time
    
    if ret == 1:
        pass
    else:
        print "setting failed"

    comedi.comedi_close(dev)
    
	
def acquirecontrol():
	diowrite(2, 1, 1)

def releasecontrol():
	diowrite(2, 1, 0)

def beamblank():
	diowrite(2, 0, 1)
	
def beamunblank():
	diowrite(2, 0, 0)
	
def getimage(nx, ny, n):
	dev = comedi.comedi_open("/dev/comedi0")
	outsubdevice = 1
	insubdevice = 0
	xchannel = 0
	ychannel = 1
	inchannel = 0
	analogref = comedi.AREF_GROUND
	arange =  0
	
	image = numpy.zeros((nx,ny), float)
	
	for y in range(0, ny):
		write_data = int(  (float(y)/(ny-1) ) * 65535)	
		msg = comedi.comedi_data_write(dev, outsubdevice, ychannel, arange, analogref, write_data)
		for x in range(0, nx):
			write_data = int(  (float(x)/(nx-1) ) * 65535)
			msg = comedi.comedi_data_write(dev, outsubdevice, xchannel, arange, analogref, write_data)
			pixel = 0.0
			for i in range(0, n):
				result = comedi.comedi_data_read(dev,insubdevice,inchannel,arange,analogref)
				pixel = pixel + float(result[1])
			pixel = pixel/n
#			print pixel,
			msg=result[0]
			image[x][y] = pixel
#		print
		
	comedi.comedi_close(dev)
	return pixel

def sety(voltage):
    dev = comedi.comedi_open("/dev/comedi0")
    outsubdevice = 1
    insubdevice = 0
    xchannel = 0
    ychannel = 1
    inchannel = 0
    analogref = comedi.AREF_GROUND
    arange =  0
    write_data = int(  (float(voltage)+10)/20*65535)
    msg = comedi.comedi_data_write(dev, outsubdevice, ychannel, arange, analogref, write_data)
    comedi.comedi_close(dev)
	
def setx(voltage):
    dev = comedi.comedi_open("/dev/comedi0")
    outsubdevice = 1
    insubdevice = 0
    xchannel = 0
    ychannel = 1
    inchannel = 0
    analogref = comedi.AREF_GROUND
    arange =  0
    write_data = int(  (float(voltage)+10)/20*65535)
    msg = comedi.comedi_data_write(dev, outsubdevice, xchannel, arange, analogref, write_data)
    comedi.comedi_close(dev)
			
def imagecapture_part(xb, yb, xe, ye, nx, ny, n):
    dev = comedi.comedi_open("/dev/comedi0")
    outsubdevice = 1
    insubdevice = 0
    xchannel = 0
    ychannel = 1
    inchannel = 0
    analogref = comedi.AREF_GROUND
    arange =  0

    image = numpy.zeros((nx,ny), float)
	
    for y in range(ny, 0, -1):
        y = y-1
        write_data = int(  (float(y)/(ny-1) *(ye-yb) + yb ) * 65535)
        msg = comedi.comedi_data_write(dev, outsubdevice, ychannel, arange, analogref, write_data)
        for x in range(0, nx):
#            print "( " + str(x) + ", " + str(y) + ")" 
            write_data = int(  (float(x)/(nx-1) * (xe-xb) + xb ) * 65535)
            msg = comedi.comedi_data_write(dev, outsubdevice, xchannel, arange, analogref, write_data)
            pixel = 0.0
            for i in range(0, n):
                result = comedi.comedi_data_read(dev,insubdevice,inchannel,arange,analogref)
                pixel = pixel + float(result[1])
            pixel = pixel/n
#            print pixel,
            msg=result[0]
            image[x][y] = pixel
        print
		
    comedi.comedi_close(dev)
    return image

def writegrid(nx, ny, tmin, tmax):
    deltat = (tmax-tmin)/(float(nx)*ny-1)
    print "nx =", nx, ", ny =", ny
    print "deltat = ", deltat
    t = tmin
    for x in range(0, nx):
        setx(10-(float(x)/(nx-1))*20)
#        print "x: ", 10-(float(x)/(nx-1))*20
#        print "(nx) ", x
        for y in range(0, ny):
            sety((float(y)/(ny-1))*20-10)
            print "t (", 10-(float(x)/(nx-1))*20, ",", (float(y)/(ny-1))*20-10, ") = ", t
#            print " (ny) ", y, 
#            print "  t", t, 
            time.sleep(0.3)
            timedbeamunblank(t)
            t = t+deltat
        print



def SetVoltage(device, subdevice, channel, voltage):
    analogref = comedi.AREF_GROUND
    outrange =  0
    inrange = 0
    ret = ""
    try:
        print "trying to open " + device
        dev = comedi.comedi_open(device)
    except:
        ret = "WARNING: cannot open device " + device + " are you allowed to write to it?"
        return ret
    
    write_data = int((voltage + 10)* 3276.6)
    msg = str(comedi.comedi_data_write(dev, subdevice, channel, outrange, analogref, write_data))
    if msg == "-1":
        msg = "Writing failed"
    comedi.comedi_close(dev)
    return msg

def GetVoltage(device, subdevice, channel, points=1):
    dev = comedi.comedi_open(device)
    analogref = comedi.AREF_GROUND
    arange = 0
    value = 0
    for i in range(0, points):
        result = comedi.comedi_data_read(dev,subdevice,channel,arange,analogref);
        datain=result[1]
        msg=result[0]
        value = value + ((float(datain)/3276.6)-10)
    comedi.comedi_close(dev)
    return value/points

def align_makehole(vx, vy, delay):
    if outsubdevice == "":
        return False
        
    print "hello"
    acquirecontrol()
    
    print "setting x voltage", vx
    setx(vx)

    print "setting y voltage", vy
    sety(vy)

    print "hang on for a second"
    # making sure the settings take ... 
    time.sleep(1)
    print "unblank the beam for ", delay, " seconds"
    timedbeamunblank(delay)
    releasecontrol()
    return True


def get_filename():
    dialog = gtk.FileChooserDialog("Open..",
                                   None,
                                   gtk.FILE_CHOOSER_ACTION_OPEN,
                                   (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                                    gtk.STOCK_OPEN, gtk.RESPONSE_OK))
    dialog.set_default_response(gtk.RESPONSE_OK)

    filter = gtk.FileFilter()
    filter.set_name("All files")
    filter.add_pattern("*")
    dialog.add_filter(filter)

    filter = gtk.FileFilter()
    filter.set_name("Images")
    filter.add_mime_type("image/png")
    filter.add_mime_type("image/jpeg")
    filter.add_mime_type("image/gif")
    filter.add_pattern("*.png")
    filter.add_pattern("*.jpg")
    filter.add_pattern("*.gif")
    filter.add_pattern("*.tif")
    filter.add_pattern("*.xpm")
    dialog.add_filter(filter)

    response = dialog.run()
    filename = ""
    if response == gtk.RESPONSE_OK:
#        print dialog.get_filename(), 'selected'
        filename = dialog.get_filename()
    elif response == gtk.RESPONSE_CANCEL:
        print 'Closed, no files selected'
        filename = ""
    dialog.destroy()
    return filename 

class pulsedata():
        def __init__(self):
                pass
        def getlast(self, user, host, hostbutton, directory):
                if hostbutton:
                        return ""
                        pass
                else:
                        files = filter(os.path.isfile, glob.glob(directory + "/" + user + "*.cfg"))
                        files.sort(key=lambda x: os.path.getmtime(x))
                        try:
                            return files[-1]
                        except:
                            return ""

def im_get_new():
    global im_buffer
    global directory 
    #msgfile = self.builder.get_object("directory").get_text() + "/im.txt"
    msgfile = directory + "/im.txt"
    fh = open(msgfile, "r")
    newmesgs = False
    try:
        fcntl.flock(fh.fileno(), fcntl.LOCK_EX + fcntl.LOCK_NB)
        global im_pos
        fh.seek(im_pos)
#    tv = self.builder.get_object("im_text").get_buffer()
        for line in fh:
            newmesgs = True
            im_buffer.insert_at_cursor(line)
#        tv.insert_at_cursor(line)
#         print line
        im_pos = fh.tell()
        fh.close()
        global im_scroll
        adj = im_scroll.get_adjustment()
        im_scroll.set_value(adj.upper)
    except:
        print "could not get exclusive lock, will try later"

    if newmesgs: 
        try:
            os.system("beep")
        except:
            print "beep! (can't run 'beep', is it installed?)"
    
    gobject.timeout_add(1000,im_get_new)

class DaqWindow(gtk.Window):
    __gtype_name__ = "DaqWindow"

    def __init__(self):
        """__init__ - This function is typically not called directly.
        Creation a DaqWindow requires redeading the associated ui
        file and parsing the ui definition extrenally,
        and then calling DaqWindow.finish_initializing().

        Use the convenience function NewDaqWindow to create
        DaqWindow object.

        """
        pass
        
    def delete_last_data(self, builder):
        import re
        import shutil
        deviceid = re.compile("deviceid")
        
        # hides last dataset, by setting the deviceid to 'autohide'
        # and keeping the old deviceid in 'olddeviceid'
        filename = self.builder.get_object("objid").get_text()
        filein = open(filename, "r")
        fileout = open(filename + "tmp", "w")
        for line in filein:
            if deviceid.match(line):
                print "match! " + line
                fileout.write("deviceid autohide\n")
                fileout.write("old" + line)
            else:
                fileout.write(line)
        filein.close()
        fileout.close()
        shutil.move(filename + "tmp", filename)
        
    def finish_initializing(self, builder):
        """finish_initalizing should be called after parsing the ui definition
        and creating a DaqWindow object with it in order to finish
        initializing the start of the new DaqWindow instance.

        """
        #get a reference to the builder and set up the signals
        self.builder = builder
        self.builder.connect_signals(self)

        global launchpad_available
        if launchpad_available:
            # see https://wiki.ubuntu.com/UbuntuDevelopment/Internationalisation/Coding for more information
            # about LaunchpadIntegration
            helpmenu = self.builder.get_object('menu3')
            if helpmenu:
                LaunchpadIntegration.set_sourcepackagename('daq')
                LaunchpadIntegration.add_items(helpmenu, 0, False, True)
            else:
                launchpad_available = False

        #uncomment the following code to read in preferences at start up
        #dlg = PreferencesDaqDialog.NewPreferencesDaqDialog()
        #self.preferences = dlg.get_preferences()

        #code for other initialization actions should be added here

#        vbox = self.builder.get_object("vbox1") # VBox()

        self.builder.get_object("user").set_text(user)
#     put linearscan figure
        table = self.builder.get_object("linearscan")
            # a gtk.DrawingArea
        table.attach(canvas, 1, 2, 0, 5)
        canvas.show()
#     put timescan figure

        table = self.builder.get_object("timetrace")
        table.attach(tcanvas, 1, 2, 0, 4)
        tcanvas.show()

        table = self.builder.get_object("timetrace2")
        table.attach(tt2canvas, 1, 2, 0, 4)
        tt2canvas.show()

#       put translocation figure
        table = self.builder.get_object("translocation")
        table.attach(trcanvas, 1, 2, 0, 5)
        trcanvas.show()

        table = self.builder.get_object("reflection")
        table.attach(rfcanvas, 1, 2, 0, 4)
        rfcanvas.show()

        table = self.builder.get_object("reflection2")
        table.attach(rf2canvas, 1, 2, 0, 4)
        rf2canvas.show()
        
        table = self.builder.get_object("align")
        table.attach(aligncanvas, 1, 2, 0, 4)
        aligncanvas.show()

        if str(insubdevice) == "":
            inmsg = "NONE"
        else:
            inmsg = str(insubdevice)
        if str(outsubdevice) == "":
            outmsg = "NONE"
        else:
            outmsg = str(outsubdevice)
        lastdata = pulsedata()
        lastfile = lastdata.getlast(self.builder.get_object("user").get_text(),self.builder.get_object("host").get_text(),self.builder.get_object("hostbutton").get_active(), self.builder.get_object("directory").get_text())

        self.builder.get_object("auxchannel").set_text("1")
        self.builder.get_object("statusbar1").push(0, "Device = " + device + ", analogin = " + inmsg + ", analogout = " + outmsg + ", last file : " + lastfile)
        
        self.align_updatetime(builder)
        global im_buffer
        im_buffer = self.builder.get_object("im_text").get_buffer()
        global im_scroll 
        im_scroll = self.builder.get_object("im_scrolledwindow").get_vscrollbar()
        global directory 
        directory = self.builder.get_object("directory").get_text()
        im_get_new()
        gobject.timeout_add(1000,im_get_new)
        self.builder.get_object("im_message").set_text("DAQ started on " + hostname)        
        self.im_send(None)

    def change_directory(self, widget): 
        global directory    
        directory = self.builder.get_object("directory").get_text()
        print "directory changed to " + directory 

    def im_send(self, widget):
        tv = self.builder.get_object("im_text").get_buffer()
#        tv.set_text("hi there") 
        text = self.builder.get_object("im_message").get_text()
        now = strftime("%H:%M:%S", localtime())
        text = user + " (" + now + ") : " + text + "\n"
        tv.insert_at_cursor(text)
        global directory
        directory = self.builder.get_object("directory").get_text()
        msgfile = directory + "/im.txt"
        fh = open(msgfile, "a")
        # get exclusive blocking lock
        fcntl.flock(fh.fileno(), fcntl.LOCK_EX)
        fh.write(text)
        global im_pos
        # print im_pos
        im_pos = fh.tell()
        # print im_pos
        fh.close()
        self.builder.get_object("im_message").set_text("")

    def im_new(self, widget):
        msgfile = self.builder.get_object("directory").get_text() + "/im.txt"
        fh = open(msgfile, "r")
        global im_pos
        fh.seek(im_pos)
        tv = self.builder.get_object("im_text").get_buffer()
        for line in fh:
            tv.insert_at_cursor(line)
        im_pos = fh.tell()
        fh.close()
        global im_scroll
#        scroll = self.builder.get_object("im_scrolledwindow").get_vscrollbar()
#        print scroll.get_value()
        adj = im_scroll.get_adjustment()
#        print adj.upper
        im_scroll.set_value(adj.upper)
           
    def align_xform(self, widget):
        optx = []
        opty = []
        opt = []
        images = []
        imagedir = self.builder.get_object("alignimagedirectory").get_text()
        for i in range(0, 4):
            try:
                optx.append(float(self.builder.get_object("align_mark" + str(i+1) + "_optx").get_text()))
                opty.append(float(self.builder.get_object("align_mark" + str(i+1) + "_opty").get_text()))
                images.append(imagedir + "/" + hostname + "." + str(i+1))
            except:
                self.builder.get_object("statusbar1").push(0, "Marker " + str(i+1) + " coordinates invalid")
                return                        
        print images
        
        
        try: 
            sizex = float(self.builder.get_object("align_sizex").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "SEM X scale invalid")
            return
        try: 
            sizey = float(self.builder.get_object("align_sizey").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "SEM Y scale invalid")
            return
            
        try: 
            u = float(self.builder.get_object("align_u").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "SEM 2nd order correction invalid")
            return
        try: 
            xorg = float(self.builder.get_object("align_hole_optx").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Optical X hole position invalid")
            return
        try: 
            yorg = float(self.builder.get_object("align_hole_opty").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Optical Y hole position invalid")
            return
        try: 
            xsens = float(self.builder.get_object("align_xsens").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "SEM X sensitivity invalid")
            return
        try: 
            ysens = float(self.builder.get_object("align_ysens").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "SEM Y sensitivity invalid")
            return
        try: 
            refmag = float(self.builder.get_object("align_refmag").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Sensitivity reference magnification invalid")
            return
        try: 
            mag = float(self.builder.get_object("align_mag").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Magnification invalid")
            return

        for i in range(0, len(optx)):
            opt.append(complex(optx[i], opty[i]))

        y = array(opt)
                    
        align_markerposfile = self.builder.get_object("align_markerposfile").get_text()
        try: 
            data = loadtxt(align_markerposfile)
        except: 
            self.builder.get_object("statusbar1").push(0, "Error reading file " + align_markerposfile)
            return
        
        self.builder.get_object("statusbar1").push(0, "ok") 
        
        x = data[:,0] + complex(0,1)*data[:,1]
      
        print "sem:", x     
        print "opt:", y

        # rescaling coordinates        
        xavg = mean(x)
        yavg = mean(y)
        xr = mean(abs(x - xavg))
        yr = mean(abs(y - yavg))
        X = (x - xavg)/xr
        Y = (y - yavg)/yr
        
        n = []
        N = []
        F = []
        opt2sem = range(0, len(x))
        sem2opt = range(0, len(x))
        for i in range(0, len(x)):
            index = argmin(abs(X-Y[i]))
            print "sem:", index, "opt: ", i
            opt2sem[i] = index
            sem2opt[index] = i
            n.append(x[index])
            if self.builder.get_object("align_mark" + str(i+1) + "_on").get_active():
                N.append(x[i])
                F.append(y[i])
            
#            n[i] = x[index]
#            print index
        

#        x = array(n)
        
        try:
            for i in range(0, len(data)):
                self.builder.get_object("align_mark" + str(i+1) + "_semx").set_text(str(real(x[opt2sem[i]])))
                self.builder.get_object("align_mark" + str(i+1) + "_semy").set_text(str(imag(x[opt2sem[i]])))
                image = self.builder.get_object("align_image" + str(i+1))
                image.set_from_file(imagedir + hostname + "." + str(opt2sem[i]+1) + ".png.m.png")                  
                image = self.builder.get_object("align_image_th" + str(i+1))
                image.set_from_file(imagedir + hostname + "." + str(opt2sem[i]+1) + ".thresh.png")                
        except:
            self.builder.get_object("statusbar1").push(0, "Error, too many markers in file? (length = " + str(len(x)+1))
            return
        
        
        # NOW x is in order of OPT
        x = array(N)
        y = array(F)
        print "after filter x:", x
        print "after filter y:", y        
        # swapping x and y (this is because we're reimplementing something we used to do in gnu octave, and we used 
        # those variables differently then above
        
#        print "x"
#        print x
#        print "y"
#        print y 
            
        newx = y.copy()
        y = x.copy()
        x = newx.copy()
        
#        print "x"
#        print x
#        print "y"
#        print y 

        cx = sizex/2
        cy = -sizey/2 # NB inverting y scale!
        cprime = complex(cx, cy)
        
        r = y.copy()
        k = r-cprime
        delta = k*u
        rprime = r - delta
        print "rprime" 
        
        print rprime 
        c = polyfit(x, rprime, 1)
        
        error = mean(abs(x*c[0] + c[1] - rprime)) # this is a number in pixels, convert to m
        # we're assuming the pixels are square, in other words, the X pixel size and y pixel size set the same aspect ratio
        # as the x sensitivity and y sensitivity. We'll take the average pixelsize here, but that should not be necessary if the
        # pixels are square
        pixelsize = mean(20*refmag/(float(xsens)*mag*sizex), 20*refmag/(float(ysens)*mag*sizey))
        print "pixelsize " + str(pixelsize)
        error = error*pixelsize
        self.builder.get_object("align_error").set_text(str(error) + " m")
        
        oldc = xorg + complex(0,1)*yorg
        newc = c[0]*oldc + c[1]

        newc = newc + (newc-cprime)*u
        
        legendtext = str(abs(c[0])) + "X, " + str(angle(c[0])*180/pi) + " deg, ( " + str(real(c[1])) + ", " + str(imag(c[1])) + ")"
        self.builder.get_object("align_transform").set_text(legendtext)
        
        self.builder.get_object("align_hole_semx").set_text(str(real(newc)))
        self.builder.get_object("align_hole_semy").set_text(str(imag(newc)))
        
        ax = alignfig.add_subplot(111, xlabel="SEM X", ylabel="SEM Y", axis_bgcolor='w', axisbg='w')
        # the Cairo backend cannot plot more than ~18000 points, so we limit that here
        plot1 = ax.plot(real(y), imag(y), 'o', alpha=0.5)
#        plot1.legend(loc='upper right')
#        ax.title(legendtext)
        ax.plot(real(newc), imag(newc), 'o', alpha=0.5)
#        ax.plot(real(newc*
        aligncanvas.draw()
        
        
    def align_burn(self, widget, data=None):
        deviceid = self.builder.get_object("deviceid").get_text()
        if deviceid == "":
            self.builder.get_object("statusbar1").push(0, "Error: Set Device ID first")
            os.system("zenity --error --text=\"Error: Set Device ID first\"")
            return    
    
        try: 
            sizex = float(self.builder.get_object("align_sizex").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "SEM X scale invalid")
            return
        try: 
            sizey = float(self.builder.get_object("align_sizey").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "SEM Y scale invalid")
            return
        try: 
            cx = float(self.builder.get_object("align_hole_semx").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Sem X hole position invalid")
            return
        try: 
            cy = float(self.builder.get_object("align_hole_semy").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Sem Y hole position invalid")
            return
        try: 
            delay = float(self.builder.get_object("align_time").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Time invalid")
            return
            
        xvoltrange = 20
        yvoltrange = 20

        cx = xvoltrange*(0.5-cx/sizex)
        cy = yvoltrange*(0.5+cy/sizey)
         
        value = align_makehole(cx, cy, delay)

        if value:
            self.builder.get_object("statusbar1").push(0, "Burn success")
        else:
            self.builder.get_object("statusbar1").push(0, "Error: Burn failed") 
            
        pulseid = self.new_id(widget)
        imgfilename = pulseid + "." + imgext
        alignfig.savefig(imgfilename, dpi=300, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)
        imgfilename = pulseid + "." + imgext2
        alignfig.savefig(imgfilename, dpi=300, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)

        # Now we save the configuration used for getting the data
        filename = pulseid + "-ALIGN.cfg"
        self.builder.get_object("objid").set_text(filename)
        print filename
        fh = open(filename,"w")
        fh.write("TYPE = ALIGN\n")
        fh.write("deviceid " + self.builder.get_object("deviceid").get_text() + "\n")
        fh.write("sizex " + self.builder.get_object("align_sizex").get_text() + "\n")
        fh.write("sizey " + self.builder.get_object("align_sizey").get_text() + "\n")
        fh.write("current " + self.builder.get_object("align_current").get_text() + "\n")
        fh.write("mag " + self.builder.get_object("align_mag").get_text() + "\n")
        fh.write("dosage " + self.builder.get_object("align_charge").get_text() + "\n")
        fh.write("xorg " + self.builder.get_object("align_hole_semx").get_text() + "\n")
        fh.write("yorg " + self.builder.get_object("align_hole_semy").get_text() + "\n")
        fh.write("transform " + self.builder.get_object("align_transform").get_text() + "\n")
        fh.write("centerx " + self.builder.get_object("align_hole_semx").get_text() + "\n")
        fh.write("centery " + self.builder.get_object("align_hole_semy").get_text() + "\n")
        fh.write("meanerror " + self.builder.get_object("align_error").get_text() + "\n")        
        fh.write("otherparameters " + self.builder.get_object("parameters").get_text() + "\n")
        for i in range(1,5):
            if self.builder.get_object("align_mark" + str(i) + "_on").get_active():
                fh.write("mark" + str(i) + "x " + self.builder.get_object("align_mark" + str(i) + "_semx").get_text() + "\n")
                fh.write("mark" + str(i) + "y " + self.builder.get_object("align_mark" + str(i) + "_semy").get_text() + "\n")
                fh.write("mark" + str(i) + "xOrg " + self.builder.get_object("align_mark" + str(i) + "_optx").get_text() + "\n")
                fh.write("mark" + str(i) + "yOrg " + self.builder.get_object("align_mark" + str(i) + "_opty").get_text() + "\n")

        fh.close()
        # close configuration file 

        
            
    
             
        
    def align_updatetime(self, widget, data=None):
        try:
            current = float(self.builder.get_object("align_current").get_text())
            charge = float(self.builder.get_object("align_charge").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error : Invalid Value in charge or current")
            return
        try:
            self.builder.get_object("align_time").set_text(str(charge/current))
        except:
            self.builder.get_object("statusbar1").push(0, "Exception : is the current 0?")

    def sync_data(self, widget, data=None):
        os.system("/home/bin/sync-data-desktop " + user)

    def hostbutton_toggled(self, widget, data=None):
        if self.builder.get_object("hostbutton").get_active():
            self.builder.get_object("host").set_has_frame(True)
        else:
            self.builder.get_object("host").set_has_frame(False)

    def hostvideobutton_toggled(self, widget, data=None):
        if self.builder.get_object("hostvideobutton").get_active():
            self.builder.get_object("videohost").set_has_frame(True)
        else:
            self.builder.get_object("videohost").set_has_frame(False)


    def import_image(self, widget, data=None):
        deviceid = self.builder.get_object("deviceid").get_text()
        if deviceid == "":
            self.builder.get_object("statusbar1").push(0, "Error: Set Device ID first")
            os.system("zenity --error --text=\"Error: Set Device ID first\"")
            return

        newid = self.new_id(widget)
#        os.system("zenity --file-selection")
#        import subprocess as sp
#        infile = os.popen("zenity --file-selection")
#        filename = infile.read()
#        filename = filename.rstrip(os.linesep)
#        infile.close()
        filename = get_filename()
        outfile = newid + "-IMG.jpg"
        cfgfile  = newid + "-IMG.cfg"
        self.builder.get_object("objid").set_text(cfgfile)
        i = Image(filename)
        inverted = self.builder.get_object("IMG_invert").get_active()
        if inverted:
            i.flip()
            i.flop()
        i.write(outfile)

        fh = open(cfgfile,"w")
        fh.write("TYPE = IMG\n")
        fh.write("deviceid " + deviceid + "\n")
        fh.write("inverted " + str(inverted) + "\n")
        fh.write("otherparameters " + self.builder.get_object("parameters").get_text() + "\n")
        fh.close()
            
        print '"' + filename +  '"'
        print newid
        self.builder.get_object("statusbar1").push(0, "Saved in " + outfile)

    def new_id(self, widget, data=None):
        now = strftime("%Y%m%d-%H%M%S", localtime())
        basedir = self.builder.get_object("directory").get_text()
        if basedir[-1] != "/":
            basedir = basedir + "/"
        filename = basedir + user + "-" + now 
        return filename

    def tr_start_func(self, widget, data=None):
        deviceid = self.builder.get_object("deviceid").get_text()
        if deviceid == "":
            self.builder.get_object("statusbar1").push(0, "Error: Set Device ID first")
            os.system("zenity --error --text=\"Error: Set Device ID first\"")
            return
                        
        otherparameters = self.builder.get_object("parameters").get_text()
        
        if device == "":
            self.builder.get_object("statusbar1").push(0, "No DAQ device found")
            return
        if insubdevice == "":
            self.builder.get_object("statusbar1").push(0, "No Analog In Subdevice found")
            return
        if outsubdevice == "":
            self.builder.get_object("statusbar1").push(0, "No Analog Out Subdevice found")
            return
        try:
            number_of_scans = int(self.builder.get_object("tr_number_of_scans").get_text())
        except:
            print "number of scans not an integer"
            self.builder.get_object("statusbar1").push(0, "Error: number of scans not an integer")
            return
        try:
            frequency = float(self.builder.get_object("tr_frequency").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error: frequency invalid")
            return
        try:
            duration = float(self.builder.get_object("tr_duration").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error: duration invalid")
            return
        try:
            if self.builder.get_object("tr_lpf_on").get_active():           
                averagepoints = int(self.builder.get_object("tr_lpf").get_text())
            else:
                averagepoints = 1
        except:
            self.builder.get_object("statusbar1").push(0, "Error: averagepoints invalid")
            return

        try:
            yscale = float(self.builder.get_object("tr_yscale").get_text())
            yoffset = float(self.builder.get_object("tr_yoffset").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error : Invalid Value")
            return

        timebase = 1/frequency;
#        self.builder.get_object("tr_timebase").set_text(str(timebase))
        bar = self.builder.get_object("progressbar")
        bar.show()

#       need this for source type noise
#        c = exp(-abs((arange(-30.0, 30.0, 1))/2))
#        c = ampl*c/sum(c)
#       end need this for source type noise

#        t=arange(0, duration+timebase, timebase)

        now = strftime("%Y%m%d-%H%M%S", localtime())

        # now we save the data 
        basedir = self.builder.get_object("directory").get_text()
        if basedir[-1] != "/":
            basedir = basedir + "/"
        filename = basedir + user + "-" + now + "-" + str(i) + ".dat"
        
        rms = 0.0
        tempfig = Figure(figsize=(5,4), dpi=80)
        tempax = tempfig.add_subplot(111)
        for i in range(0, number_of_scans):
            frequency = float(self.builder.get_object("tr_frequency").get_text())
            print "duration " + str(round(frequency*duration))
#            os.system("/home/bin/ain " + str(round(frequency*duration)) + " > /tmp/ain.dat 2> /dev/null")
            os.system("/home/bin/mscan 1 " + str(int(round(duration*frequency))) + " " + str(int(round(1e9/frequency))))
            try:
#                data = loadtxt('/tmp/ain.dat', delimiter=' ')
                data = loadtxt('/tmp/data.dat')
                self.builder.get_object("statusbar1").push(0, str(len(data)) + " points read")
                os.system("rm /tmp/data.dat")   # clear it so other users don't trip over the file
#                print "data length " + str(len(data))
            except:
                print "ERROR trying to load /tmp/data.dat, tell Henk Postma\n"
                self.builder.get_object("statusbar1").push(0, "ERROR trying to load /tmp/data.dat, tell Henk Postma")
                bar.hide()
                return

            if averagepoints == 1:
                t = data[:,0]
                x = data[:,1]
            else:
                newlength = int(floor(len(data)/averagepoints))
#                    print "newlength " + str(newlength)
                x = data[0:newlength, 1]
                t = data[0:newlength, 0]
#                    print "length is " + str(len(x))
                frequency = frequency/averagepoints
                for count in range(0, newlength):
                    x[count] = mean(data[count*averagepoints:(count+1)*averagepoints-1,1])
                    t[count] = data[count*averagepoints, 0]
            rms = rms + std(x)
            bar.set_fraction(float(i+1)/number_of_scans)
            t = t/1e9
            x = x/65536*20-10
            x = x/yscale-yoffset
            
            # remove temporary files            
#            os.system("rm /tmp/ain.dat")


            while gtk.events_pending():
                gtk.main_iteration()
                                        

            
            savetxt(filename, transpose((t, x)), delimiter='\t')
            print filename
            self.builder.get_object("statusbar1").push(0, "Saved in " + filename)
            # end save 
 
#            if i == 0:
#                y = p[0]
#                f = p[1]
#            else:
#                y = y + p[0]

        xtext = self.builder.get_object("tr_xlabel").get_text() + " (" + self.builder.get_object("tr_xunit").get_text() + ")"
        ytext = self.builder.get_object("tr_ylabel").get_text() + " (" + self.builder.get_object("tr_yunit").get_text() + ")"
        ax = trfig.add_subplot(211, xlabel=xtext, ylabel=ytext, axis_bgcolor='w', axisbg='w')
        # the Cairo backend cannot plot more than ~18000 points, so we limit that here
        if len(x) > 18000:
            xshort = x[0:17999]
            tshort = t[0:17999]
            ax.plot(tshort, xshort)
            self.builder.get_object("statusbar1").push(0, "Only plotted first 18000 points, FFT is done on all. Saved in " + filename)
        else:
            ax.plot(t, x)

#        fx = fft(x)
#        try:
#            lpf = int(self.builder.get_object("tr_lpf").get_text())
#            print str(lpf)
#        except:
#            lpf = 10
#            print "integer expected for low pass filter frequency"
#        try:
#            hpf = int(self.builder.get_object("tr_hpf").get_text())
#            print str(hpf)
#        except:
#            hpf = 10
#            print "integer expected for high pass filter frequency"
#                
#        for i in range(len(fx)):
#            if self.builder.get_object("tr_lpf_on").get_active():
#                if i > lpf:
#                    fx[i] = 0
#            if self.builder.get_object("tr_hpf_on").get_active():
#                if i < hpf:
#                    fx[i] = 0
#            filtereddata = ifft(fx)
#            ax.plot(t, filtereddata)
            
        try:
            numberofbins = int(self.builder.get_object("tr_bins").get_text())
        except:
            numberofbins = 50
        
        try:    
            p = histogram(filtereddata, bins=numberofbins)
        except:
            p = histogram(x, bins=numberofbins)


        xtext = self.builder.get_object("tr_ylabel").get_text() + " (" + self.builder.get_object("tr_yunit").get_text() + ")"
        ytext = "Count (-)"

        ay = trfig.add_subplot(212, xlabel=xtext, ylabel=ytext)
        
        # sometimes, for reasons probably related to details of the psd routine, 
        # the integral under the PSD does not evaluate to the RMS in time space squared. 
        # so we correct for that here
        try:
            correction = integral/(rms*rms)
            y = y/correction
            integral = integral/correction
            print correction
        except:
            pass
#        self.builder.get_object("tr_rms").set_text(str( "%1.3g" %rms))
        
        histx = p[1]
        histy = p[0]
        histx = histx[:-1]
        
        ay.plot(histx, histy, '-', alpha=0.5)
             
        if len(x) > 18000:
            self.builder.get_object("tr_points").set_text("18000 of " + str(len(x)))
        else:
            self.builder.get_object("tr_points").set_text(str(len(x)))

        print str(len(x))

        imgfilename = basedir + user + "-" + now + "." + imgext
        trfig.savefig(imgfilename, dpi=300, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)
        imgfilename = basedir + user + "-" + now + "." + imgext2
        trfig.savefig(imgfilename, dpi=300, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)

        # Now we save the configuration used for getting the data
        filename = basedir + user + "-" + now + "-TR.cfg"
        self.builder.get_object("objid").set_text(filename)
        print filename
        fh = open(filename,"w")
        fh.write("TYPE = TR\n")
        fh.write("deviceid " + deviceid + "\n")
        fh.write("frequency " + self.builder.get_object("tr_frequency").get_text() + "\n")
        fh.write("duration " + self.builder.get_object("tr_duration").get_text() + "\n")
        fh.write("number_of_scans " + self.builder.get_object("tr_number_of_scans").get_text() + "\n")
        fh.write("xlabel " + self.builder.get_object("tr_xlabel").get_text() + "\n")
        fh.write("xunit " + self.builder.get_object("tr_xunit").get_text() + "\n")
        fh.write("ylabel " + self.builder.get_object("tr_ylabel").get_text() + "\n")
        fh.write("yoffset " + self.builder.get_object("tr_yoffset").get_text() + "\n")        
        fh.write("yscale " + self.builder.get_object("tr_yscale").get_text() + "\n")
        fh.write("yunit " + self.builder.get_object("tr_yunit").get_text() + "\n")
        fh.write("points " + self.builder.get_object("tr_points").get_text() + "\n")
        fh.write("rms " + str(rms) + "\n")
        fh.write("otherparameters " + otherparameters + "\n")
        fh.close()
        # close configuration file 

        bar.set_fraction(0)
        bar.hide()

        trcanvas.draw()

        # now we save the data 
        basedir = self.builder.get_object("directory").get_text()
        if basedir[-1] != "/":
            basedir = basedir + "/"
        filename = basedir + user + "-" + now + ".HIST.dat"
        savetxt(filename, transpose((histx, histy)), delimiter='\t')
        self.builder.get_object("statusbar1").push(0, "Saved in " + filename)
        print filename        
        
        return

    def proc_save(self, widget, data=None):
        deviceid = self.builder.get_object("deviceid").get_text()
        if deviceid == "":
            self.builder.get_object("statusbar1").push(0, "Error: Set Device ID first")
            os.system("zenity --error --text=\"Error: Set Device ID first\"")
            return
        otherparameters = self.builder.get_object("parameters").get_text()
        process = self.builder.get_object("processing").get_text()
        
        now = strftime("%Y%m%d-%H%M%S", localtime())
        basedir = self.builder.get_object("directory").get_text()
        if basedir[-1] != "/":
            basedir = basedir + "/"

        # Now we save the configuration used for getting the data
        filename = basedir + user + "-" + now + "-PROC.cfg"
        self.builder.get_object("objid").set_text(filename)
        print filename
        fh = open(filename,"w")
        fh.write("TYPE = PROC\n")
        fh.write("deviceid " + deviceid + "\n")
        fh.write("otherparameters " + process + "\n")
#        fh.write("process " + process + "\n")
        fh.close()

        self.builder.get_object("statusbar1").push(0, "Saved in " + filename)
        
        return

    def tt2_start_func(self, widget, data=None):
        deviceid = self.builder.get_object("deviceid").get_text()
        if deviceid == "":
            self.builder.get_object("statusbar1").push(0, "Error: Set Device ID first")
            os.system("zenity --error --text=\"Error: Set Device ID first\"")
            return
        otherparameters = self.builder.get_object("parameters").get_text()
        try:
            frequency = float(self.builder.get_object("tt2_frequency").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error: frequency invalid")
            return
        try:
            duration = float(self.builder.get_object("tt2_duration").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error: duration invalid")
            return 
        try:
            nchan =  int(self.builder.get_object("tt2_nchan").get_text())      
        except:
            self.builder.get_object("statusbar1").push(0, "Error: number of channels invalid")
            return 

        # mscan comes from ~/home/postma/daq/ccode/mscan/src/ain 
        # it takes three arguments 
        #     number of channels to acquire
        #     number of samples per channel
        #     sample period (ns)
        # and writes to /tmp/data.dat 

        try:
            os.system("/home/bin/mscan " + str(nchan) + " " + str(int(round(duration*frequency))) + " " + str(int(round(1e9/frequency))))        
        except:
            self.builder.get_object("statusbar1").push(0, "Error: /home/bin/mscan run failed")
#            return 
        data = loadtxt('/tmp/data.dat') 
        os.system("rm /tmp/data.dat")
        data[:,0] = data[:,0]/1e9 
        t = data[:,0]
        for i in range(0, nchan):
            data[:,i+1] = data[:,i+1]/65536*20-10
#            x = data[:,i+1]/65536*20-10
            x = data[:,i+1]
            ax = tt2fig.add_subplot(nchan*100+10+i+1, axis_bgcolor='w', axisbg='w')
            ax.plot(t, x)

        tt2canvas.draw()

        newid = self.new_id(widget)
        imgfilename = newid + "." + imgext
        tt2fig.savefig(imgfilename, dpi=300, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)
        imgfilename = newid + "." + imgext2
        tt2fig.savefig(imgfilename, dpi=300, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)

        cfgfile  = newid + "-TT2.cfg"
        datfile = newid + ".dat"
        savetxt(datfile, data, '%f')
        self.builder.get_object("objid").set_text(cfgfile)
        fh = open(cfgfile,"w")
        fh.write("TYPE = TT2\n")
        fh.write("deviceid " + deviceid + "\n")
        fh.write("otherparameters " + otherparameters + "\n")
        fh.write("frequency " + str(frequency) + "\n")
        fh.write("duration " + str(duration) + "\n")
        fh.write("nchan " + str(nchan) + "\n")
        fh.close()

    def t_start_func(self, widget, data=None):
        deviceid = self.builder.get_object("deviceid").get_text()
        if deviceid == "":
            self.builder.get_object("statusbar1").push(0, "Error: Set Device ID first")
            os.system("zenity --error --text=\"Error: Set Device ID first\"")
            return
        otherparameters = self.builder.get_object("parameters").get_text()
        
        if device == "":
            self.builder.get_object("statusbar1").push(0, "No DAQ device found")
            return
        if insubdevice == "":
            self.builder.get_object("statusbar1").push(0, "No Analog In Subdevice found")
            return
        if outsubdevice == "":
            self.builder.get_object("statusbar1").push(0, "No Analog Out Subdevice found")
            return
        try:
            number_of_scans = int(self.builder.get_object("t_number_of_scans").get_text())
        except:
            print "number of scans not an integer"
            self.builder.get_object("statusbar1").push(0, "Error: number of scans not an integer")
            return
        try:
            frequency = float(self.builder.get_object("t_frequency").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error: frequency invalid")
            return
        try:
            duration = float(self.builder.get_object("t_duration").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error: duration invalid")
            return
        try:
            averagepoints = int(self.builder.get_object("t_average_points").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error: averagepoints invalid")
            return

        try:
            yscale = float(self.builder.get_object("t_yscale").get_text())
            yoffset = float(self.builder.get_object("t_yoffset").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error : Invalid Value")
            return

        timebase = 1/frequency;
        self.builder.get_object("t_timebase").set_text(str(timebase))
        bar = self.builder.get_object("progressbar")
        bar.show()

#       need this for source type noise
#        c = exp(-abs((arange(-30.0, 30.0, 1))/2))
#        c = ampl*c/sum(c)
#       end need this for source type noise

#        t=arange(0, duration+timebase, timebase)

        now = strftime("%Y%m%d-%H%M%S", localtime())
        rms = 0.0
        tempfig = Figure(figsize=(5,4), dpi=80)
        tempax = tempfig.add_subplot(111)
        for i in range(0, number_of_scans):
            frequency = float(self.builder.get_object("t_frequency").get_text())
#            print "duration " + str(round(frequency*duration))
            os.system("/home/bin/ain " + str(round(frequency*duration)) + " > /tmp/ain.dat 2> /dev/null")
            try:
#                data = loadtxt('/tmp/ain.dat', delimiter=' ')
                data = loadtxt('/tmp/ain.dat')
#                print "data length " + str(len(data))
                if averagepoints == 1:
                    t = data[:,0]
                    x = data[:,1]/yscale-yoffset
                else:
                    newlength = int(floor(len(data)/averagepoints))
#                    print "newlength " + str(newlength)
                    x = data[0:newlength, 1]
                    t = data[0:newlength, 0]
#                    print "length is " + str(len(x))
                    frequency = frequency/averagepoints
                    for count in range(0, newlength):
                        x[count] = mean(data[count*averagepoints:(count+1)*averagepoints-1,1])/yscale-yoffset
                        t[count] = data[count*averagepoints, 0]
                rms = rms + std(x)
                bar.set_fraction(float(i+1)/number_of_scans)
            except:
                print "ERROR trying to load /tmp/ain.dat, tell Henk Postma\n"
                self.builder.get_object("statusbar1").push(0, "ERROR trying to load /tmp/ain.dat, tell Henk Postma")
                bar.hide()
                return

            while gtk.events_pending():
                gtk.main_iteration()

            # remove temporary files so other users don't trip over it  
            os.system("rm /tmp/ain.dat")

            p = tempax.psd(x-x.mean(axis=0), Fs=frequency, NFFT=2048)
            
            # now we save the data 

            basedir = self.builder.get_object("directory").get_text()
            if basedir[-1] != "/":
                basedir = basedir + "/"
            filename = basedir + user + "-" + now + "-" + str(i) + ".dat"
            
            savetxt(filename, transpose((t, x)), delimiter='\t')
            print filename
            self.builder.get_object("statusbar1").push(0, "Saved in " + filename)
            # end save 
 
            if i == 0:
                y = p[0]
                f = p[1]
            else:
                y = y + p[0]

        xtext = self.builder.get_object("t_xlabel").get_text() + " (" + self.builder.get_object("t_xunit").get_text() + ")"
        ytext = self.builder.get_object("t_ylabel").get_text() + " (" + self.builder.get_object("t_yunit").get_text() + ")"
        ax = tfig.add_subplot(211, xlabel=xtext, ylabel=ytext, axis_bgcolor='w', axisbg='w')
        # the Cairo backend cannot plot more than ~18000 points, so we limit that here
        if len(x) > 18000:
            xshort = x[0:17999]
            tshort = t[0:17999]
            ax.plot(tshort, xshort)
            self.builder.get_object("statusbar1").push(0, "Only plotted first 18000 points, FFT is done on all. Saved in " + filename)
        else:
            ax.plot(t, x)

        xtext = "Frequency (Hz)"
        ytext = self.builder.get_object("t_ylabel").get_text() + " PSD (" + self.builder.get_object("t_yunit").get_text() + "^2/Hz)"

        ay = tfig.add_subplot(212, xlabel=xtext, ylabel=ytext)
        
        y = y/number_of_scans
        df = mean(f[1:]-f[0:-1])
        rms = rms/number_of_scans
        integral = sum(y)*df

        # sometimes, for reasons probably related to details of the psd routine, 
        # the integral under the PSD does not evaluate to the RMS in time space squared. 
        # so we correct for that here
        try:
            correction = integral/(rms*rms)
            y = y/correction
            integral = integral/correction
            print correction
        except:
            pass
        self.builder.get_object("t_rms").set_text(str( "%1.3g" %rms))
        self.builder.get_object("t_df").set_text(str( "%1.3g" % df))
        self.builder.get_object("t_sum").set_text(str( "%1.3g" % integral))

        ay.loglog(f, y, '-', alpha=0.5)
        maxim = max(y)
        self.builder.get_object("t_max").set_text(str( "%1.3g" % maxim))
        if len(x) > 18000:
            self.builder.get_object("t_points").set_text("18000 of " + str(len(x)))
        else:
            self.builder.get_object("t_points").set_text(str(len(x)))
        
        imgfilename = basedir + user + "-" + now + "." + imgext
        tfig.savefig(imgfilename, dpi=300, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)
        imgfilename = basedir + user + "-" + now + "." + imgext2
        tfig.savefig(imgfilename, dpi=300, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)


        # Now we save the configuration used for getting the data
        filename = basedir + user + "-" + now + "-TT.cfg"
        self.builder.get_object("objid").set_text(filename)
        print filename
        fh = open(filename,"w")
        fh.write("TYPE = TT\n")
        fh.write("deviceid " + deviceid + "\n")
        fh.write("frequency " + self.builder.get_object("t_frequency").get_text() + "\n")
        fh.write("duration " + self.builder.get_object("t_duration").get_text() + "\n")
        fh.write("number_of_scans " + self.builder.get_object("t_number_of_scans").get_text() + "\n")
        fh.write("xlabel " + self.builder.get_object("t_xlabel").get_text() + "\n")
        fh.write("xunit " + self.builder.get_object("t_xunit").get_text() + "\n")
        fh.write("ylabel " + self.builder.get_object("t_ylabel").get_text() + "\n")
        fh.write("yoffset " + self.builder.get_object("t_yoffset").get_text() + "\n")        
        fh.write("yscale " + self.builder.get_object("t_yscale").get_text() + "\n")
        fh.write("yunit " + self.builder.get_object("t_yunit").get_text() + "\n")
        fh.write("points " + self.builder.get_object("t_points").get_text() + "\n")
        fh.write("rms " + str(rms) + "\n")
        fh.write("max " + str(maxim) + "\n")
        fh.write("integral " + str(integral) + "\n")
        fh.write("otherparameters " + otherparameters + "\n")
        fh.close()
        # close configuration file 

        bar.set_fraction(0)
        bar.hide()

        tcanvas.draw()

        # now we save the data 
        basedir = self.builder.get_object("directory").get_text()
        if basedir[-1] != "/":
            basedir = basedir + "/"
        filename = basedir + user + "-" + now + ".PSD.dat"
        
        savetxt(filename, transpose((f, y)), delimiter='\t')
        self.builder.get_object("statusbar1").push(0, "Saved in " + filename)
        print filename        
        
        return
        
    def XYsetaux(self, widget, data=None):
        deviceid = self.builder.get_object("deviceid").get_text()
        if deviceid == "":
            self.builder.get_object("statusbar1").push(0, "Error: Set Device ID first")
            os.system("zenity --error --text=\"Error: Set Device ID first\"")
            return
        otherparameters = self.builder.get_object("parameters").get_text()
        try:
            auxchannel = int(self.builder.get_object("auxchannel").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "ERROR: aux channel invalid")
            return
            
        try:
            auxlevel = float(self.builder.get_object("auxlevel").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "ERROR: aux level invalid")
            return

        try:
            auxoffset = float(self.builder.get_object("auxoffset").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "ERROR: aux offset invalid")
            return

        try:
            auxscale = float(self.builder.get_object("auxscale").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "ERROR: aux scale invalid")
            return
            
        
        auxlabel = self.builder.get_object("auxlabel").get_text()
        auxunit = self.builder.get_object("auxunit").get_text()
        
        analogref = comedi.AREF_GROUND
        outrange =  0
        inrange = 0

        try:
            print "trying to open " + device
            dev = comedi.comedi_open(device)
        except:
            self.builder.get_object("statusbar1").push(0, "WARNING: cannot open device " + device + " are you allowed to write to it?")
            return
        
        write_data = int((auxlevel/auxscale-auxoffset + 10)* 3276.6)
        msg = comedi.comedi_data_write(dev, outsubdevice, auxchannel, outrange, analogref, write_data)
        comedi.comedi_close(dev)

        now = strftime("%Y%m%d-%H%M%S", localtime())
        basedir = self.builder.get_object("directory").get_text()
        if basedir[-1] != "/":
            basedir = basedir + "/"

        # Now we save the configuration used for getting the data
        filename = basedir + user + "-" + now + "-AUXSET.cfg"
        self.builder.get_object("objid").set_text(filename)
        print filename
        fh = open(filename,"w")
        fh.write("TYPE = AUXSET\n")
        fh.write("deviceid " + deviceid + "\n")
        fh.write("otherparameters " + otherparameters + "\n")
        fh.write("auxchannel " + str(auxchannel) + "\n")
        fh.write("auxscale " + str(auxscale) + "\n")
        fh.write("auxoffset " + str(auxoffset) + "\n")
        fh.write("auxlevel " + str(auxlevel) + "\n")
        fh.write("auxunit " + str(auxunit) + "\n")
        fh.write("auxlabel " + str(auxlabel) + "\n")
        fh.close()

        self.builder.get_object("statusbar1").push(0, "Saved in " + filename)

        return
        
        
    def rf_start_func(self, widget, data=None):
        deviceid = self.builder.get_object("deviceid").get_text()
        if deviceid == "":
            self.builder.get_object("statusbar1").push(0, "Error: Set Device ID first")
            os.system("zenity --error --text=\"Error: Set Device ID first\"")
            return
        otherparameters = self.builder.get_object("parameters").get_text()
        
        if device == "":
            self.builder.get_object("statusbar1").push(0, "No DAQ device found")
            return
        if insubdevice == "":
            self.builder.get_object("statusbar1").push(0, "No Analog In Subdevice found")
            return
        if outsubdevice == "":
            self.builder.get_object("statusbar1").push(0, "No Analog Out Subdevice found")
            return

        try:
            rfchan = int(self.builder.get_object("rf_rfchan").get_text())
            lochan = int(self.builder.get_object("rf_lochan").get_text())
        except:
            print "rf or lo channel invalid"
            self.builder.get_object("statusbar1").push(0, "Error: rf or lo channel invalid")
            return
            
        print rfchan
        print lochan

        try:
            startf = float(self.builder.get_object("rf_startf").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error: frequency invalid")
            return

        try:
            endf = float(self.builder.get_object("rf_endf").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error: frequency invalid")
            return

        try:
            stepf = float(self.builder.get_object("rf_stepf").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error: frequency invalid")
            return

        try:
            df = float(self.builder.get_object("rf_df").get_text())
#           Fixme : assuming it's MHz, need to properly check that
            dfreal = df*1e6
        except:
            self.builder.get_object("statusbar1").push(0, "Error: frequency invalid")
            return
            
        funit = self.builder.get_object("rf_funit").get_text()

        try:
            duration = float(self.builder.get_object("rf_duration").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error: duration invalid")
            return

        try:
            delay = float(self.builder.get_object("rf_delay").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error: delay invalid")
            return           
            
        try:
            samplefrequency = float(self.builder.get_object("rf_samplefrequency").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error: sample frequency invalid")
            return
            
        try:
            averagepoints = int(self.builder.get_object("t_average_points").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error: averagepoints invalid")
            return

        try:
            yscale = float(self.builder.get_object("t_yscale").get_text())
            yoffset = float(self.builder.get_object("t_yoffset").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error : Invalid Value")
            return

#        timebase = 1/frequency;
#        self.builder.get_object("t_timebase").set_text(str(timebase))
        bar = self.builder.get_object("progressbar")
        bar.show()

#       need this for source type noise
#        c = exp(-abs((arange(-30.0, 30.0, 1))/2))
#        c = ampl*c/sum(c)
#       end need this for source type noise

#        t=arange(0, duration+timebase, timebase)

        now = strftime("%Y%m%d-%H%M%S", localtime())
        rms = 0.0
#        tempfig = Figure(figsize=(5,4), dpi=80)
#        tempax = tempfig.add_subplot(111)

        num = (endf-startf)/stepf
        x = range(0, num+1)
        y = range(0, num+1)
        for i in range(0, num+1):
#        for i in range(0, number_of_scans):
            frequency = i*stepf + startf
            print "frequency " + str(frequency)
            os.system(gpibwrite + " " + str(rfchan) + " \" FREQ " + str(frequency) + " " + funit + "\"")
            time.sleep(0.2)
            os.system(gpibwrite + " " + str(lochan) + " \" FREQ " + str(frequency+df) + " " + funit + "\"")
            time.sleep(delay)
            x[i] = frequency            
#            print "duration " + str(round(frequency*duration))
            tempfile = "/tmp/" + user + "-ain.dat"
            os.system("/home/bin/ain " + str(round(samplefrequency*duration)) + " > " + tempfile + " 2> /dev/null")
    
            try:
                data = loadtxt(tempfile)  
            except:
                print "ERROR trying to load /tmp/ain.dat, tell Henk Postma\n"
                self.builder.get_object("statusbar1").push(0, "ERROR trying to load /tmp/ain.dat, tell Henk Postma")
                bar.hide()
                return
                                
#            inphase = dot(data[:,1], sin(data[:,0]*2*pi*dfreal))
#            outphase = dot(data[:,1], cos(data[:,0]*2*pi*dfreal))
#            y[i] = sqrt(inphase**2 + outphase**2)/len(data)
            rms = std(data[:,1])
            y[i] = rms
                
            bar.set_fraction(float(i)/num)

            while gtk.events_pending():
                gtk.main_iteration()
            
            # now we save the data 

        basedir = self.builder.get_object("directory").get_text()
        if basedir[-1] != "/":
            basedir = basedir + "/"
        filename = basedir + user + "-" + now + ".dat"
        
        savetxt(filename, transpose((x, y)), delimiter='\t')
        print filename
        self.builder.get_object("statusbar1").push(0, "Saved in " + filename)
            # end save 
 
        xtext = "Frequency (" + self.builder.get_object("rf_funit").get_text() + ")"
        ytext = self.builder.get_object("rf_label").get_text() + " (" + self.builder.get_object("rf_unit").get_text() + ")"
        ax = rffig.add_subplot(111, xlabel=xtext, ylabel=ytext, axis_bgcolor='w', axisbg='w')
        # the Cairo backend cannot plot more than ~18000 points, so we limit that here
        ax.plot(x, y)

        imgfilename = basedir + user + "-" + now + "." + imgext
        rffig.savefig(imgfilename, dpi=300, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)
        imgfilename = basedir + user + "-" + now + "." + imgext2
        rffig.savefig(imgfilename, dpi=300, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)
        
        # Now we save the configuration used for getting the data
        filename = basedir + user + "-" + now + "-RF.cfg"
        self.builder.get_object("objid").set_text(filename)
        print filename
        fh = open(filename,"w")
        fh.write("TYPE = RF\n")
        fh.write("deviceid " + deviceid + "\n")
        fh.write("rf_rfgpib " + str(rfchan) + "\n")
        fh.write("rf_logpib " + str(lochan) + "\n")
        fh.write("rf_startf " + str(startf) + "\n")
        fh.write("rf_endf " + str(endf) + "\n")
        fh.write("rf_stepf " + str(stepf) + "\n")
        fh.write("rf_df " + str(df) + "\n")
        fh.write("rf_funit " + funit + "\n")
        fh.write("rf_channelin " + self.builder.get_object("rf_channelin").get_text() + "\n")
        fh.write("rf_amplification " + self.builder.get_object("rf_amplification").get_text() + "\n")
        fh.write("rf_samplefrequency " + self.builder.get_object("rf_samplefrequency").get_text() + "\n")
        fh.write("rf_channelin " + self.builder.get_object("rf_channelin").get_text() + "\n")
        fh.write("rf_label " + self.builder.get_object("rf_label").get_text() + "\n")
        fh.write("rf_channelin " + self.builder.get_object("rf_channelin").get_text() + "\n")
        fh.write("rf_unit " + self.builder.get_object("rf_unit").get_text() + "\n")
        fh.write("rf_duration " + self.builder.get_object("rf_duration").get_text() + "\n")
        fh.write("otherparameters " + otherparameters + "\n")
        fh.close()
        # close configuration file 

        bar.set_fraction(0)
        bar.hide()

        rfcanvas.draw()     

        return

    def rf2_getoffset1(self, widget, data=None):
        try:
            channelin1 = int(self.builder.get_object("rf2_channelin1").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "ERROR: channel 1 invalid")
            return
        try:
            pointsperfrequency = int(self.builder.get_object("rf2_pointsperfrequency").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "ERROR: pointsperfrequency invalid")
            return           

        offset = GetVoltage(device, insubdevice, channelin1, pointsperfrequency)
        self.builder.get_object("rf2_offset1").set_text(str(offset))
        print offset
        
        return

    def rf2_getoffset2(self, widget, data=None):
        try:
            channelin2 = int(self.builder.get_object("rf2_channelin2").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "ERROR: channel 2 invalid")
            return
        try:
            pointsperfrequency = int(self.builder.get_object("rf2_pointsperfrequency").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "ERROR: pointsperfrequency invalid")
            return           

        offset = GetVoltage(device, insubdevice, channelin2, pointsperfrequency)
        self.builder.get_object("rf2_offset2").set_text(str(offset))
        print offset
        
        return
        

    def rf2_start_func(self, widget, data=None):
        deviceid = self.builder.get_object("deviceid").get_text()
        if deviceid == "":
            self.builder.get_object("statusbar1").push(0, "Error: Set Device ID first")
            os.system("zenity --error --text=\"Error: Set Device ID first\"")
            return
        otherparameters = self.builder.get_object("parameters").get_text()

        try:
            channelin1 = int(self.builder.get_object("rf2_channelin1").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "ERROR: channel 1 invalid")
            return

        try:
            channelin2 = int(self.builder.get_object("rf2_channelin2").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "ERROR: channel 2 invalid")
            return

        try:
            pointsperfrequency = int(self.builder.get_object("rf2_pointsperfrequency").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "ERROR: pointsperfrequency invalid")
            return

        try:
            amplification = int(self.builder.get_object("rf2_amplification").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "ERROR: amplification invalid")
            return
        
        if device == "":
            self.builder.get_object("statusbar1").push(0, "No DAQ device found")
            return
        if insubdevice == "":
            self.builder.get_object("statusbar1").push(0, "No Analog In Subdevice found")
            return
        if outsubdevice == "":
            self.builder.get_object("statusbar1").push(0, "No Analog Out Subdevice found")
            return

        try:
            rfchan = int(self.builder.get_object("rf2_rfchan").get_text())
        except:
            print "rf channel invalid"
            self.builder.get_object("statusbar1").push(0, "Error: rf channel invalid")
            return
            
        print rfchan

        try:
            startf = float(self.builder.get_object("rf2_startf").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error: frequency invalid")
            return

        try:
            endf = float(self.builder.get_object("rf2_endf").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error: frequency invalid")
            return

        try:
            stepf = float(self.builder.get_object("rf2_stepf").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error: frequency invalid")
            return

        funit = self.builder.get_object("rf2_funit").get_text()

        try:
            delay = float(self.builder.get_object("rf2_delay").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error: delay invalid")
            return
            
        try:
            offset1 = float(self.builder.get_object("rf2_offset1").get_text())
            print "offset 1 :", offset1
        except:
            self.builder.get_object("statusbar1").push(0, "Error: offset1 invalid")
            return

        try:
            offset2 = float(self.builder.get_object("rf2_offset2").get_text())
            print "offset 2 :", offset2
        except:
            self.builder.get_object("statusbar1").push(0, "Error: offset2 invalid")
            return
        

#        timebase = 1/frequency;
#        self.builder.get_object("t_timebase").set_text(str(timebase))
        bar = self.builder.get_object("progressbar")
        bar.show()

#       need this for source type noise
#        c = exp(-abs((arange(-30.0, 30.0, 1))/2))
#        c = ampl*c/sum(c)
#       end need this for source type noise

#        t=arange(0, duration+timebase, timebase)

        now = strftime("%Y%m%d-%H%M%S", localtime())
        rms = 0.0
#        tempfig = Figure(figsize=(5,4), dpi=80)
#        tempax = tempfig.add_subplot(111)

        num = round((endf-startf)/stepf)
        x = range(0, num+1)
#        y = range(0, num+1)
#        y2 = range(0, num+1)
        data = range(0, num+1)
        data2 = range(0, num+1)
        ampl = range(0, num+1)
        phase = range(0, num+1)
#        z = range(0, num+1)
        for i in range(0, num+1):
#        for i in range(0, number_of_scans):
            frequency = i*stepf + startf
            print "frequency " + str(frequency)
            if True:
                os.system(gpibwrite + " " + str(rfchan) + " \" FREQ " + str(frequency) + " " + funit + "\"")
            else:
                pass
            time.sleep(delay)
            x[i] = frequency
            data[i] = (GetVoltage(device, insubdevice, channelin1, pointsperfrequency)-offset1)/amplification
            data2[i] = (GetVoltage(device, insubdevice, channelin2, pointsperfrequency)-offset2)/amplification
#            z[i] = complex(data[i], data2[i])
            ampl[i] = sqrt(data[i]**2 + data2[i]**2)
            phase[i] = math.atan2(data2[i], data[i])

            bar.set_fraction(float(i+1)/(num+1))
            while gtk.events_pending():
                gtk.main_iteration()
            
 
        xtext = "Frequency (" + self.builder.get_object("rf2_funit").get_text() + ")"
        ytext = self.builder.get_object("rf2_label").get_text() + " (" + self.builder.get_object("rf2_unit").get_text() + ")"
        ytext1 = "Real " + self.builder.get_object("rf2_label").get_text() + " (" + self.builder.get_object("rf2_unit").get_text() + ")"
        ytext2 = "Imag " + self.builder.get_object("rf2_label").get_text() + " (" + self.builder.get_object("rf2_unit").get_text() + ")"
        ytextampl = "Amplitude " + self.builder.get_object("rf2_label").get_text() + " (" + self.builder.get_object("rf2_unit").get_text() + ")"
        ytextphase = "Phase " + self.builder.get_object("rf2_label").get_text() + " (rad)"

        ax = rf2fig.add_subplot(221, xlabel=xtext, ylabel=ytextampl, axis_bgcolor='w', axisbg='w')
        # the Cairo backend cannot plot more than ~18000 points, so we limit that here
        ax.plot(x, ampl)
        
        ay = rf2fig.add_subplot(222, xlabel=xtext, ylabel=ytextphase, axis_bgcolor='w', axisbg='w')
        ay.plot(x, phase)
        
        az = rf2fig.add_subplot(223, xlabel=ytext1, ylabel=ytext2, axis_bgcolor='w', axisbg='w')
        az.plot(data, data2)

        bar.set_fraction(0)
        bar.hide()

        basedir = self.builder.get_object("directory").get_text()
        if basedir[-1] != "/":
            basedir = basedir + "/"

        imgfilename = basedir + user + "-" + now + "." + imgext
        rf2fig.savefig(imgfilename, dpi=300, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)
        imgfilename = basedir + user + "-" + now + "." + imgext2
        rf2fig.savefig(imgfilename, dpi=300, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)
        rf2canvas.draw() 
        
        if True:
            # now we save the data 
            filename = basedir + user + "-" + now + ".dat"       
            savetxt(filename, transpose((x, data, data2, ampl, phase)), delimiter='\t')

            print filename
            self.builder.get_object("statusbar1").push(0, "Saved in " + filename)
            # end save 

            # Now we save the configuration used for getting the data
            filename = basedir + user + "-" + now + "-RF2.cfg"
            self.builder.get_object("objid").set_text(filename) 
            print filename
            fh = open(filename,"w")
            fh.write("TYPE = RF2\n")
            fh.write("deviceid " + deviceid + "\n")
            fh.write("rf2_delay " + str(delay) + "\n")
            fh.write("rf2_funit " + funit + "\n")
            fh.write("rf2_stepf " + str(stepf) + "\n")
            fh.write("rf2_endf " + str(endf) + "\n")
            fh.write("rf2_startf " + str(startf) + "\n")
            fh.write("rf2_rfchan " + str(rfchan) + "\n")
            fh.write("rf2_pointsperfrequency " + str(pointsperfrequency) + "\n")
            fh.write("rf2_amplification " + str(amplification) + "\n")
            fh.write("rf2_channelin1 " + str(channelin1) + "\n")
            fh.write("rf2_channelin2 " + str(channelin2) + "\n")
            fh.write("rf2_offset1 " + str(offset1) + "\n")
            fh.write("rf2_offset2 " + str(offset2) + "\n")
            fh.write("rf2_unit " + self.builder.get_object("rf2_unit").get_text() + "\n")
            fh.write("otherparameters " + otherparameters + "\n")          
            fh.close()
            # close configuration file 

            bar.set_fraction(0)
            bar.hide()

        return

    def browse(self, widget, data=None): 
        host = self.builder.get_object("pulsehost").get_text()
        os.system("gnome-open http://" + host + " &")
#                    self.builder.get_object("browsebutton").set_uri("http://" + self.builder.get_object("pulsehost").get_text())

    def start_func(self, widget, data=None):
        deviceid = self.builder.get_object("deviceid").get_text()
        if deviceid == "":
            self.builder.get_object("statusbar1").push(0, "Error: Set Device ID first")
            os.system("zenity --error --text=\"Error: Set Device ID first\"")
            return
        otherparameters = self.builder.get_object("parameters").get_text()

        if device == "":
            self.builder.get_object("statusbar1").push(0, "No DAQ device found")
            return
        if insubdevice == "":
            self.builder.get_object("statusbar1").push(0, "No Analog In Subdevice found")
            return
        if outsubdevice == "":
            self.builder.get_object("statusbar1").push(0, "No Analog Out Subdevice found")
            return

        xtext = self.builder.get_object("xlabel").get_text()
        xunit = self.builder.get_object("xunit").get_text()
        if xunit != "":
            xtext = xtext + " (" + xunit + ")"

        ytext = self.builder.get_object("ylabel").get_text()
        yunit = self.builder.get_object("yunit").get_text()
        if yunit != "":
            ytext = ytext + " (" + yunit + ")"

        try:
            channelin = int(self.builder.get_object("channelin").get_text())
            channelout = int(self.builder.get_object("channelout").get_text())
            xscale = float(self.builder.get_object("xscale").get_text())
            yscale = float(self.builder.get_object("yscale").get_text())
            xoffset = float(self.builder.get_object("xoffset").get_text())
            yoffset = float(self.builder.get_object("yoffset").get_text())
            startx = float(self.builder.get_object("startx").get_text())
            stopx = float(self.builder.get_object("stopx").get_text())
            increment = float(self.builder.get_object("increment").get_text())
            wait = float(self.builder.get_object("wait").get_text())
            sweeprate = float(self.builder.get_object("sweeprate").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error : Invalid Value")
            return
            
        try:
            timeperpoint = increment/sweeprate
        except: 
            timeperpoint = 0    
        print timeperpoint
    #    print pointsperprogress
        analogref = comedi.AREF_GROUND
        outrange =  0
        inrange = 0

        ax = fig.add_subplot(111, xlabel=xtext, ylabel=ytext, axis_bgcolor='w', axisbg='w')
        try:
            print "trying to open " + device
            dev = comedi.comedi_open(device)
        except:
            self.builder.get_object("statusbar1").push(0, "WARNING: cannot open device " + device + " are you allowed to write to it?")
            return

        self.builder.get_object("statusbar1").push(0, "opening " + device)
        points = 10 # will modify this in a minute
    #    increment = float((stopx-startx)/(points-1))
        if self.builder.get_object("cycle").get_active():
    # if we cycle, we 
    #        measure from 0 to startx
    #         measure from startx to stopx
    #        measure from stopx to 0
            x = arange(0, startx, -increment).tolist()
            x.extend(arange(startx, stopx, increment).tolist()) # (range(0, points)/xscale-xoffset + 10) * 3276.6
            x.extend(arange(stopx, 0-increment, -increment).tolist())
            points = len(x)
            #        print points
            y = range(0, points)
        else:
            x = arange(startx, stopx+increment, increment).tolist() # (range(0, points)/xscale-xoffset + 10) * 3276.6
            points = len(x)
            #        print points
            y = range(0, points)
        bar = self.builder.get_object("progressbar")
        bar.show()

        # we only need to  update the progress bar twice a second, so that means every so many points:
        try:
            pointsperprogress = int(round(0.5/timeperpoint))
        except:
            self.builder.get_object("statusbar1").push(0, "Error : Invalid Value")
            return
        if pointsperprogress == 0:
            pointsperprogress = 1

        i = 0
        for xvalue in x:
            write_data = int((xvalue/xscale-xoffset + 10)* 3276.6)
            msg = comedi.comedi_data_write(dev, outsubdevice, channelout, outrange, analogref, write_data)
            if i == 0:
                time.sleep(wait)
            time.sleep(timeperpoint)
            if i % pointsperprogress == 0:
                bar.set_fraction(float(i+1)/points)
            while gtk.events_pending():
                gtk.main_iteration()
            result = comedi.comedi_data_read(dev,insubdevice,channelin,inrange,analogref)
            datain=result[1]
            msg=result[0]
            y[i] = ((float(datain)/3276.6)-10)/yscale-yoffset
            i = i+1
    #        x = x + increment
        bar.set_fraction(0)
        bar.hide()
        comedi.comedi_close(dev)

        now = strftime("%Y%m%d-%H%M%S", localtime())
        #        print now
        basedir = self.builder.get_object("directory").get_text()
        if basedir[-1] != "/":
            basedir = basedir + "/"
        filename = basedir + user + "-" + now + ".dat"
        
        f = open(filename,"w")
        i = 0
        while i < points:
            f.write(str(x[i]) + "\t" + str(y[i]) + "\n");
            i = i+1
        f.close()

        ax.plot(x,y,'o', alpha=0.5)
        coeff = polyfit(x, y, 1)
        fitx=[startx, stopx]
        fity=[startx*coeff[0]+coeff[1], stopx*coeff[0]+coeff[1]]
        self.builder.get_object("slope").set_text(str( "%1.3g" % coeff[0]))
        self.builder.get_object("offset").set_text(str("%1.3g" % coeff[1]))
        try:
            self.builder.get_object("slopeinv").set_text(str( "%1.3g" % (1/coeff[0])))
            self.builder.get_object("slopeinvunit").set_text(self.builder.get_object("xunit").get_text() + "/" + self.builder.get_object("yunit").get_text())
        except:
            pass
             

        self.builder.get_object("slopeunit").set_text(self.builder.get_object("yunit").get_text() + "/" + self.builder.get_object("xunit").get_text())
        self.builder.get_object("offsetunit").set_text(self.builder.get_object("yunit").get_text())
        ax.plot(fitx, fity, '-')
        # a gtk.DrawingArea
        # vbox.pack_start(canvas)
        print filename
        self.builder.get_object("statusbar1").push(0, "written to file " + filename)        
        # Now we save the configuration used for getting the data
        filename = basedir + user + "-" + now + "-XY.cfg"
        self.builder.get_object("objid").set_text(filename)
        f = open(filename,"w")
        f.write("TYPE = XY\n")
        f.write("deviceid " + deviceid + "\n")
        f.write("xlabel " + self.builder.get_object("xlabel").get_text() + "\n")
        f.write("xunit " + self.builder.get_object("xunit").get_text() + "\n")
        f.write("ylabel " + self.builder.get_object("ylabel").get_text() + "\n")
        f.write("yunit " + self.builder.get_object("yunit").get_text() + "\n")
        f.write("channelin " + self.builder.get_object("channelin").get_text() + "\n")
        f.write("channelout " + self.builder.get_object("channelout").get_text() + "\n")
        f.write("xscale " + self.builder.get_object("xscale").get_text() + "\n")
        f.write("yscale " + self.builder.get_object("yscale").get_text() + "\n")
        f.write("xoffset " + self.builder.get_object("xoffset").get_text() + "\n")
        f.write("yoffset " + self.builder.get_object("yoffset").get_text() + "\n")
        f.write("startx " + self.builder.get_object("startx").get_text() + "\n")
        f.write("stopx " + self.builder.get_object("stopx").get_text() + "\n")
        f.write("increment " + self.builder.get_object("increment").get_text() + "\n")
        f.write("wait " + self.builder.get_object("wait").get_text() + "\n")
        f.write("sweeprate " + self.builder.get_object("sweeprate").get_text() + "\n")
        f.write("cycle " + str(self.builder.get_object("cycle").get_active()) + "\n")
        f.write("slope " + self.builder.get_object("slope").get_text()  + "\n")
        f.write("slopeinv " + self.builder.get_object("slopeinv").get_text()  + "\n")
        f.write("offset " + self.builder.get_object("offset").get_text()  + "\n")
        f.write("otherparameters " + otherparameters + "\n")
       
        f.close()
        # close configuration file 
        
        canvas.draw()
        
        imgfilename = basedir + user + "-" + now + "." + imgext
        fig.savefig(imgfilename, dpi=300, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)
        imgfilename = basedir + user + "-" + now + "." + imgext2
        fig.savefig(imgfilename, dpi=300, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)
        

    def clear_plot(self, widget, data=None):
        fig.clear()

        # a gtk.DrawingArea
        # vbox.pack_start(canvas)
        canvas.draw()

    def t_clear_plot(self, widget, data=None):
        tfig.clear()

        # a gtk.DrawingArea
        # vbox.pack_start(canvas)
        tcanvas.draw()

    def tt2_clear_plot(self, widget, data=None):
        tt2fig.clear()

        # a gtk.DrawingArea
        # vbox.pack_start(canvas)
        tt2canvas.draw()
        
    def tr_clear_plot(self, widget, data=None):
        trfig.clear()

        # a gtk.DrawingArea
        # vbox.pack_start(canvas)
        trcanvas.draw()

    def rf_clear_plot(self, widget, data=None):
        rffig.clear()

        # a gtk.DrawingArea
        # vbox.pack_start(canvas)
        rfcanvas.draw()

    def rf2_clear_plot(self, widget, data=None):
        rf2fig.clear()

        # a gtk.DrawingArea
        # vbox.pack_start(canvas)
        rf2canvas.draw()
        
    def align_clear_plot(self, widget, data=None):
        alignfig.clear()

        # a gtk.DrawingArea
        # vbox.pack_start(canvas)
        aligncanvas.draw()

    def about(self, widget, data=None):
        """about - display the about box for daq """
        about = AboutDaqDialog.NewAboutDaqDialog()
        response = about.run()
        about.destroy()

    def preferences(self, widget, data=None):
        """preferences - display the preferences window for daq """
        prefs = PreferencesDaqDialog.NewPreferencesDaqDialog()
        response = prefs.run()
        if response == gtk.RESPONSE_OK:
            #make any updates based on changed preferences here
            pass
        prefs.destroy()

    def quit(self, widget, data=None):
        """quit - signal handler for closing the DaqWindow"""
        self.destroy()

    def on_destroy(self, widget, data=None):
        """on_destroy - called when the DaqWindow is close. """
        #clean up code for saving application state should be added here

        gtk.main_quit()


    def set_voltage(self, widget, data=None):
        deviceid = self.builder.get_object("deviceid").get_text()
        if deviceid == "":
            self.builder.get_object("statusbar1").push(0, "Error: Set Device ID first")
            os.system("zenity --error --text=\"Error: Set Device ID first\"")
            return

        if device == "":
            self.builder.get_object("statusbar1").push(0, "No DAQ device found")
            return
        if insubdevice == "":
            self.builder.get_object("statusbar1").push(0, "No Analog In Subdevice found")
            return
        if outsubdevice == "":
            self.builder.get_object("statusbar1").push(0, "No Analog Out Subdevice found")
            return
        try:
            x = float(self.builder.get_object("analogout").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Invalid value")
            return

        try:
            channelout = int(self.builder.get_object("channelout").get_text())
            xscale = float(self.builder.get_object("xscale").get_text())
            xoffset = float(self.builder.get_object("xoffset").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error : Invalid Value")
            return

        print "set to " + str(x)
        dev = comedi.comedi_open("/dev/comedi0")
        subdevice = 1
        channel = int(self.builder.get_object("channelout").get_text())
        analogref = comedi.AREF_GROUND
            
        xvalue = float(self.builder.get_object("analogout").get_text())
        print "after rescale " + str(xvalue/xscale-xoffset)
        write_data = int((xvalue/xscale-xoffset + 10)* 3276.6)
        print "write data " + str(write_data)
        #write_data = int(  ()+ 10) * 3276.6)
        range =  0
        msg = comedi.comedi_data_write(dev, subdevice, channel, range, analogref, write_data);
        self.builder.get_object("statusbar1").push(0, str(msg)+" channel : "+str(channel))
        comedi.comedi_close(dev)

    def get_voltage(self, widget, data=None):
        deviceid = self.builder.get_object("deviceid").get_text()
        if deviceid == "":
            self.builder.get_object("statusbar1").push(0, "Error: Set Device ID first")
            os.system("zenity --error --text=\"Error: Set Device ID first\"")
            return
        if device == "":
            self.builder.get_object("statusbar1").push(0, "No DAQ device found")
            return
        if insubdevice == "":
            self.builder.get_object("statusbar1").push(0, "No Analog In Subdevice found")
            return
        if outsubdevice == "":
            self.builder.get_object("statusbar1").push(0, "No Analog Out Subdevice found")
            return
        dev = comedi.comedi_open(device)

        try:
            channelin = int(self.builder.get_object("channelin").get_text())
            xscale = float(self.builder.get_object("xscale").get_text())
            yscale = float(self.builder.get_object("yscale").get_text())
            yoffset = float(self.builder.get_object("yoffset").get_text())
        except:
            self.builder.get_object("statusbar1").push(0, "Error : Invalid Value")
            return
#        subdevice = 0
#        channel = int(self.builder.get_object("channelin").get_text())
        analogref = comedi.AREF_GROUND
        range = 0
        #        datain = 0
        result = comedi.comedi_data_read(dev,insubdevice,channelin,range,analogref);
        datain=result[1]
        msg=result[0]
        #            y[i] = ((float(datain)/3276.6)-10)*yscale-yoffset
        value = ((float(datain)/3276.6)-10)/yscale-yoffset
        returnvalue = "%1.3g" % value
        self.builder.get_object("analogin").set_text(str(  returnvalue    ))
        self.builder.get_object("statusbar1").push(0, str(msg) + " channel : " + str(channelin))
        comedi.comedi_close(dev)
        
    def video_view(self, widget, data=None):
        print "in video_view"
        channel = 1
        try:
            channel = int(self.builder.get_object("videoinput"))
        except:
            print "video input channel not valid"
        
        if self.builder.get_object("hostvideobutton").get_active():
            host = self.builder.get_object("videohost").get_text()
            if self.builder.get_object("video_invert").get_active():
                os.system("ssh -X " + host + " '/home/bin/microscopeviewinv " + str(channel) + "'")
            else:
                os.system("ssh -X " + host + " '/home/bin/microscopeview " + str(channel) + "'")
        else:
            if self.builder.get_object("video_invert").get_active():
                os.system("/home/bin/microscopeviewinv " + str(channel))
            else:
                os.system("/home/bin/microscopeview " + str(channel))

def NewDaqWindow():
    """NewDaqWindow - returns a fully instantiated
    DaqWindow object. Use this function rather than
    creating a DaqWindow directly.
    """

    #look for the ui file that describes the ui
    ui_filename = os.path.join(getdatapath(), 'ui', 'DaqWindow.ui')
    if not os.path.exists(ui_filename):
        ui_filename = None

    builder = gtk.Builder()
    builder.add_from_file(ui_filename)
    window = builder.get_object("daq_window")
    window.finish_initializing(builder)
    return window

if __name__ == "__main__":
    #support for command line options
    import logging, optparse
    parser = optparse.OptionParser(version="%prog %ver")
    parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help="Show debug messages")
    (options, args) = parser.parse_args()

    #set the logging level to show debug messages
    if options.verbose:
        logging.basicConfig(level=logging.DEBUG)
        logging.debug('logging enabled')

    #run the application
    window = NewDaqWindow()
    window.show()
    gtk.main()

